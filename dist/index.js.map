{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2e9dc4ab132065e8f780","webpack:///./node_modules/super-hands/reaction_components/prototypes/buttons-proto.js","webpack:///./src/index.ts","webpack:///./src/BaseComponent.ts","webpack:///./node_modules/aframe-typescript-toolkit/src/index.ts","webpack:///./node_modules/aframe-typescript-toolkit/src/aframe_wrapper.ts","webpack:///./node_modules/aframe-typescript-toolkit/src/entity_builder.ts","webpack:///./node_modules/super-hands/index.js","webpack:///./node_modules/super-hands/systems/super-hands-system.js","webpack:///./node_modules/super-hands/reaction_components/hoverable.js","webpack:///./node_modules/super-hands/reaction_components/grabbable.js","webpack:///./node_modules/super-hands/reaction_components/prototypes/physics-grab-proto.js","webpack:///./node_modules/super-hands/reaction_components/stretchable.js","webpack:///./node_modules/super-hands/reaction_components/drag-droppable.js","webpack:///./node_modules/super-hands/reaction_components/draggable.js","webpack:///./node_modules/super-hands/reaction_components/droppable.js","webpack:///./node_modules/super-hands/reaction_components/clickable.js"],"names":[],"mappings":"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AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;;AAEA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB;AACpB;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,OAAO;AACP;AACA,oBAAoB,UAAU,YAAY,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,GAAG;AACH;AACA,4CAA4C,+BAA+B;AAC3E;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,KAAK;AACL,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACvhBD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,KAAK;AACL;AACA,CAAC;;;;;;;ACtBD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACrCD;AACA;AACA,oBAAoB,mBAAO,CAAC,EAAoC;AAChE,oBAAoB,mBAAO,CAAC,CAA+B;AAC3D;AACA,uBAAuB;AACvB;AACA;AACA,kBAAkB,0BAA0B;AAC5C,aAAa,eAAe;AAC5B,gBAAgB;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uBAAuB;AACvB;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACrID;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA,oBAAoB,mBAAO,CAAC,CAA+B;AAC3D;AACA,uBAAuB;AACvB;AACA;AACA,iBAAiB,uBAAuB;AACxC,aAAa,eAAe;AAC5B,wBAAwB;AACxB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD,GAAG;AACH;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,uCAAuC;AACvC;AACA,GAAG;AACH;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;AClID;AACA;AACA,mBAAmB,mBAAO,CAAC,CAA+B;;AAE1D,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,mCAAmC;AACnC;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,CAAC;;;;;;;ACvDD;AACA;AACA,mBAAmB,mBAAO,CAAC,CAA+B;;AAE1D,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,2DAA2D;AAC3D;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,yDAAyD;AACzD;AACA,6BAA6B;AAC7B;AACA,CAAC;;;;;;;AC9BD;AACA;AACA,mBAAmB;AACnB,6BAA6B;AAC7B,iCAAiC;AACjC;AACA;AACA;AACA,cAAc,YAAY;AAC1B,iBAAiB,cAAc;AAC/B,kBAAkB,YAAY;AAC9B,kBAAkB;AAClB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA,+BAA+B;AAC/B;AACA,GAAG;AACH;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA,6BAA6B;AAC7B;AACA,CAAC;;;;;;;ACnGD;AACA,mBAAmB,mBAAO,CAAC,CAA+B;AAC1D,gEAAgE;AAChE;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,2DAA2D;AAC3D;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,GAAG;AACH;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,CAAC","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AframeToolkitExample\"] = factory();\n\telse\n\t\troot[\"AframeToolkitExample\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2e9dc4ab132065e8f780","// common code used in customizing reaction components by button\r\nmodule.exports = (function () {\r\n  function buttonIsValid (evt, buttonList) {\r\n    return buttonList.length === 0 ||\r\n        buttonList.indexOf(evt.detail.buttonEvent.type) !== -1\r\n  }\r\n  return {\r\n    schema: {\r\n      startButtons: {default: []},\r\n      endButtons: {default: []}\r\n    },\r\n    startButtonOk: function (evt) {\r\n      return buttonIsValid(evt, this.data['startButtons'])\r\n    },\r\n    endButtonOk: function (evt) {\r\n      return buttonIsValid(evt, this.data['endButtons'])\r\n    }\r\n  }\r\n})()\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/prototypes/buttons-proto.js\n// module id = 0\n// module chunks = 0","import { BaseComponentSystem, BaseComponent } from './BaseComponent';\nimport { System, Component, ObjectMap, Entity } from 'aframe';\nimport 'super-hands';\n\nlet system: BaseComponentSystem;\n\nexport function main(){\n\n    system = new BaseComponentSystem();\n    system.register();\n\n    let component: BaseComponent = new BaseComponent();\n    const el = document.createElement(\"a-sphere\")\n    el.setAttribute(\"base-component\", \"a: \" + \"a\" + \"; b: \" + \"a,b,c\");\n\n    const scene = document.getElementById(\"scene\");\n    scene.appendChild(el);\n    \n}\n\nwindow.addEventListener(\"load\", () => {\n    main();\n});\n\nexport function getComponent(entity: Entity<ObjectMap<Component<any, System<any>>>>, componentName: string, delimiter?: string){\n    return AFRAME.utils.entity.getComponentProperty(entity,componentName, delimiter);\n}\n\nexport function setComponent(entity: Entity<ObjectMap<Component<any, System<any>>>>, componentName: string, value: any, delimiter?: string) {\n     AFRAME.utils.entity.setComponentProperty(entity,componentName, value, delimiter);\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/source-map-loader!./src/index.ts","import { SystemWrapper, ComponentWrapper } from \"aframe-typescript-toolkit\"\nimport { getComponent, setComponent } from './index'\n\ninterface BaseComponentSchema {\n    readonly speed: number\n}\n\nexport class BaseComponent extends ComponentWrapper<BaseComponentSchema, BaseComponentSystem> {\n    private offsetX: number = 0;\n    private maxOffset = 2;\n    private origin: {x: number, y: number};\n    private dir = 1;\n    // speed in units per second;\n    private speed = 2.5;\n\n\n    constructor() {\n        super(\"base-component\", {\n            speed: {\n                default: 4,\n            },\n        });\n    }\n\n    init() {\n        this.system.add(this)\n        AFRAME.utils.entity.setComponentProperty(this.el, \"position.x\", 0);\n        this.speed = this.data.speed;\n        this.setOrigin();\n    }\n\n    updateSchema(data: BaseComponentSchema){\n        this.speed = data.speed;\n    }\n\n    tick(time: number, timeDelta:number) {\n        let xPos: number = getComponent(this.el, \"position.x\");\n        let newPos = xPos;\n        newPos += this.speed * (timeDelta / 1000 ) * this.dir;\n        setComponent(this.el, \"position.x\", newPos);\n        if( Math.abs(xPos) > this.maxOffset ){\n            setComponent(this.el, \"position.x\", this.maxOffset * this.dir);\n            this.dir *=-1;\n        }\n    }\n\n    private setOrigin(): void {\n        this.origin = {\n            x: getComponent(this.el, \"position.x\"),\n            y: getComponent(this.el, \"position.y\"),\n        }\n    }\n}\n\n\nexport class BaseComponentSystem extends SystemWrapper {\n    constructor() {\n        super(\"base-component\")\n\n        new BaseComponent().register()\n    }\n\n    play(){\n\n    }\n\n    add(component: BaseComponent) {\n        const { speed } = component.data\n        console.log(\"base component added\");\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/source-map-loader!./src/BaseComponent.ts","import { ComponentWrapper, SystemWrapper } from \"./aframe_wrapper\"\nimport { EntityBuilder } from \"./entity_builder\"\nexport {\n    ComponentWrapper,\n    SystemWrapper,\n    EntityBuilder,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/source-map-loader!./node_modules/aframe-typescript-toolkit/src/index.ts","import * as AFrame from \"aframe\"\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// helpers\n\n/***\n * @hidden\n */\nconst hasMethod = (obj: {}, name: string) => {\n    const desc = Object.getOwnPropertyDescriptor (obj, name)\n    return !!desc && typeof desc.value === \"function\"\n}\n\n/***\n * @hidden\n */\nconst getInstanceMethodNames = (obj: {}, stop: {}) => {\n    const array: string[] = []\n    let proto = Object.getPrototypeOf (obj)\n    while (proto && proto !== stop) {\n        Object.getOwnPropertyNames (proto)\n        .forEach (name => {\n            if (name !== \"constructor\") {\n            if (hasMethod (proto, name)) {\n                array.push (name)\n            }\n            }\n        })\n        proto = Object.getPrototypeOf(proto)\n    }\n    return array\n}\n\n/**\n * Extend this class to create strongly typed A-Frame components. \n * Default implementations for component lifecycle methods such as init(), tick(), and others are provided,\n * and can be overridden for your component's specific behavior.\n */\n\nexport abstract class ComponentWrapper<SCHEMA extends object = {}, SYSTEM extends AFrame.System = AFrame.System> \n    implements AFrame.Component<SCHEMA, SYSTEM> {\n\n    el: AFrame.Entity\n    id: string\n    data: SCHEMA\n    schema: AFrame.Schema<SCHEMA>\n    system: SYSTEM\n    name: string\n\n    constructor(name: string, schema?: AFrame.Schema<SCHEMA>) {\n        this.name = name\n        this.schema = schema || {}\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // default aframe core function implementations\n\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_remove.\n     */\n    remove() {}\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_update.\n     */\n    update(oldData: {}) {}\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_updateschema.\n     */\n    extendSchema(update: {}) {}\n    flushToDOM() {}\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // default aframe core function implementations\n\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_init.\n     */\n    init() {}\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_pause.\n     */\n    pause() {}\n    /**\n     * Wraps https://aframe.io/docs/0.8.0/core/component.html#definition_lifecycle_handler_methods_play.\n     */\n    play() {}\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // special wrapper functions implementations\n\n    /***\n     * @hidden\n     */\n    merge() {\n        const funcs = getInstanceMethodNames(this, Object.prototype)\n        funcs.forEach( k => this[k] = this[k])\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // special wrapper functions implementations\n\n    destroy() {\n        const parent = this.el.parentElement\n        if (!!parent) {\n            parent.removeChild(this.el)\n        }\n    }\n\n    register() {\n        // unregister any existing component\n        if (!!AFRAME.components[this.name]) {\n            console.log(`WARNING -- unregistering already registered component with name \"${this.name}\".`)\n            delete AFRAME.components[this.name]\n        }\n\n        this.merge()\n        AFRAME.registerComponent(this.name, this)\n\n        return this\n    }\n\n    registerCallback(callbackName: string, fn: Function) {\n        this.el.addEventListener(callbackName, fn.bind(this))\n    }\n}\n\nexport abstract class SystemWrapper<SCHEMA extends { [key: string]: any } = {}>\n    implements AFrame.System {\n\n    data: SCHEMA\n    schema: AFrame.Schema<SCHEMA>\n    name: string\n\n    constructor(name: string, schema?: AFrame.Schema<SCHEMA>) {\n        this.name = name\n        this.schema = schema || {}\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // default aframe core function implementations\n\n    init() {}\n    pause() {}\n    play() {}\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // special wrapper functions implementations\n\n    /***\n     * @hidden\n     */\n    merge() {\n        const funcs = getInstanceMethodNames(this, Object.prototype)\n        funcs.forEach( k => this[k] = this[k])\n    }\n\n    register() {\n        this.merge()\n        AFRAME.registerSystem(this.name, this)\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/source-map-loader!./node_modules/aframe-typescript-toolkit/src/aframe_wrapper.ts","import { ComponentWrapper } from \"./aframe_wrapper\"\nimport * as AFrame from \"aframe\"\n\nexport interface Attributes {\n    [key: string]: {}\n}\n\nexport class EntityBuilder {\n    private entity: AFrame.Entity\n\n    constructor(type: string, attributes?: Attributes) {\n        this.entity = <AFrame.Entity> document.createElement(type)\n        if (attributes) {\n            this.setAttributes(attributes)\n        }\n    }\n\n    static create(type: string, attributes: Attributes, children?: EntityBuilder[]): EntityBuilder {\n        const builder = new EntityBuilder(type, attributes)\n        if (!!children) {\n            children.forEach( c => {\n                c.attachTo(builder.entity)\n            })\n        }\n        return builder\n    }\n\n    set(a: string, b?: any, c?: {}): EntityBuilder {\n        if (!!b && !!c) {\n            this.entity.setAttribute(a, b, c)\n        } else if (!!b) {\n            this.entity.setAttribute(a, b || \"\")\n        } else {\n            this.entity.setAttribute(a, \"\")\n        }\n        return this\n    }\n\n    setAttributes(attributes: Attributes): EntityBuilder {\n        Object.keys(attributes).forEach( k => {\n            this.set(k, attributes[k])            \n        })\n        return this\n    }\n\n    toEntity(): AFrame.Entity {\n        return this.entity\n    }\n\n    attachTo(parent?: EntityBuilder | AFrame.ANode | AFrame.Scene | AFrame.Entity | ComponentWrapper): EntityBuilder {\n        if (!parent) {\n            // attach to the scene by default\n            document.querySelector(\"a-scene\").appendChild(this.entity)\n            return this\n        }\n\n        // a parent was specified\n        if (\"el\" in parent) {\n            // there's an element in this parent; attach the entity\n            // being created there\n            parent.el.appendChild(this.entity)\n        } else {\n            // there isn't; attach directly\n            if (\"appendChild\" in parent) {\n                parent.appendChild(this.entity)\n            } else {\n                // parent.attach(this.entity)\n            }\n        }    \n\n        return this\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/source-map-loader!./node_modules/aframe-typescript-toolkit/src/entity_builder.ts","/* global AFRAME */\r\n\r\nif (typeof AFRAME === 'undefined') {\r\n  throw new Error('Component attempted to register before AFRAME was available.')\r\n}\r\n\r\nrequire('./systems/super-hands-system.js')\r\nrequire('./reaction_components/hoverable.js')\r\nrequire('./reaction_components/grabbable.js')\r\nrequire('./reaction_components/stretchable.js')\r\nrequire('./reaction_components/drag-droppable.js')\r\nrequire('./reaction_components/draggable.js')\r\nrequire('./reaction_components/droppable.js')\r\nrequire('./reaction_components/clickable.js')\r\n\r\n/**\r\n * Super Hands component for A-Frame.\r\n */\r\nAFRAME.registerComponent('super-hands', {\r\n  schema: {\r\n    colliderEvent: {default: 'hit'},\r\n    colliderEventProperty: {default: 'el'},\r\n    colliderEndEvent: {default: 'hitend'},\r\n    colliderEndEventProperty: {default: 'el'},\r\n    grabStartButtons: {\r\n      default: ['gripdown', 'trackpaddown', 'triggerdown', 'gripclose',\r\n        'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown',\r\n        'pointup', 'thumbup', 'pointingstart', 'pistolstart',\r\n        'thumbstickdown', 'mousedown', 'touchstart']\r\n    },\r\n    grabEndButtons: {\r\n      default: ['gripup', 'trackpadup', 'triggerup', 'gripopen',\r\n        'abuttonup', 'bbuttonup', 'xbuttonup', 'ybuttonup',\r\n        'pointdown', 'thumbdown', 'pointingend', 'pistolend',\r\n        'thumbstickup', 'mouseup', 'touchend']\r\n    },\r\n    stretchStartButtons: {\r\n      default: ['gripdown', 'trackpaddown', 'triggerdown', 'gripclose',\r\n        'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown',\r\n        'pointup', 'thumbup', 'pointingstart', 'pistolstart',\r\n        'thumbstickdown', 'mousedown', 'touchstart']\r\n    },\r\n    stretchEndButtons: {\r\n      default: ['gripup', 'trackpadup', 'triggerup', 'gripopen',\r\n        'abuttonup', 'bbuttonup', 'xbuttonup', 'ybuttonup',\r\n        'pointdown', 'thumbdown', 'pointingend', 'pistolend',\r\n        'thumbstickup', 'mouseup', 'touchend']\r\n    },\r\n    dragDropStartButtons: {\r\n      default: ['gripdown', 'trackpaddown', 'triggerdown', 'gripclose',\r\n        'abuttondown', 'bbuttondown', 'xbuttondown', 'ybuttondown',\r\n        'pointup', 'thumbup', 'pointingstart', 'pistolstart',\r\n        'thumbstickdown', 'mousedown', 'touchstart']\r\n    },\r\n    dragDropEndButtons: {\r\n      default: ['gripup', 'trackpadup', 'triggerup', 'gripopen',\r\n        'abuttonup', 'bbuttonup', 'xbuttonup', 'ybuttonup',\r\n        'pointdown', 'thumbdown', 'pointingend', 'pistolend',\r\n        'thumbstickup', 'mouseup', 'touchend']\r\n    },\r\n    interval: { default: 0 }\r\n  },\r\n\r\n  /**\r\n   * Set if component needs multiple instancing.\r\n   */\r\n  multiple: false,\r\n\r\n  /**\r\n   * Called once when component is attached. Generally for initial setup.\r\n   */\r\n  init: function () {\r\n    // constants\r\n    this.HOVER_EVENT = 'hover-start'\r\n    this.UNHOVER_EVENT = 'hover-end'\r\n    this.GRAB_EVENT = 'grab-start'\r\n    this.UNGRAB_EVENT = 'grab-end'\r\n    this.STRETCH_EVENT = 'stretch-start'\r\n    this.UNSTRETCH_EVENT = 'stretch-end'\r\n    this.DRAG_EVENT = 'drag-start'\r\n    this.UNDRAG_EVENT = 'drag-end'\r\n    this.DRAGOVER_EVENT = 'dragover-start'\r\n    this.UNDRAGOVER_EVENT = 'dragover-end'\r\n    this.DRAGDROP_EVENT = 'drag-drop'\r\n\r\n    // links to other systems/components\r\n    this.otherSuperHand = null\r\n\r\n    // state tracking - global event handlers (GEH)\r\n    this.gehDragged = new Set()\r\n    this.gehClicking = new Set()\r\n\r\n    // state tracking - reaction components\r\n    this.hoverEls = []\r\n    this.hoverElsIntersections = []\r\n    this.prevCheckTime = null\r\n    this.state = new Map()\r\n    this.dragging = false\r\n\r\n    this.unHover = this.unHover.bind(this)\r\n    this.unWatch = this.unWatch.bind(this)\r\n    this.onHit = this.onHit.bind(this)\r\n    this.onGrabStartButton = this.onGrabStartButton.bind(this)\r\n    this.onGrabEndButton = this.onGrabEndButton.bind(this)\r\n    this.onStretchStartButton = this.onStretchStartButton.bind(this)\r\n    this.onStretchEndButton = this.onStretchEndButton.bind(this)\r\n    this.onDragDropStartButton = this.onDragDropStartButton.bind(this)\r\n    this.onDragDropEndButton = this.onDragDropEndButton.bind(this)\r\n    this.system.registerMe(this)\r\n  },\r\n\r\n  /**\r\n   * Called when component is attached and when component data changes.\r\n   * Generally modifies the entity based on the data.\r\n   */\r\n  update: function (oldData) {\r\n    this.unRegisterListeners(oldData)\r\n    this.registerListeners()\r\n  },\r\n\r\n  /**\r\n   * Called when a component is removed (e.g., via removeAttribute).\r\n   * Generally undoes all modifications to the entity.\r\n   */\r\n  remove: function () {\r\n    this.system.unregisterMe(this)\r\n    this.unRegisterListeners()\r\n    this.hoverEls.length = 0\r\n    if (this.state.get(this.HOVER_EVENT)) {\r\n      this._unHover(this.state.get(this.HOVER_EVENT))\r\n    }\r\n    this.onGrabEndButton()\r\n    this.onStretchEndButton()\r\n    this.onDragDropEndButton()\r\n  },\r\n  tick: (function () {\r\n    let orderChanged = false\r\n    // closer objects and objects with no distance come later in list\r\n    function sorter (a, b) {\r\n      const aDist = a.distance == null ? -1 : a.distance\r\n      const bDist = b.distance == null ? -1 : b.distance\r\n      if (aDist < bDist) {\r\n        orderChanged = true\r\n        return 1\r\n      }\r\n      if (bDist < aDist) {\r\n        return -1\r\n      }\r\n      return 0\r\n    }\r\n    return function (time) {\r\n      const data = this.data\r\n      const prevCheckTime = this.prevCheckTime\r\n      if (prevCheckTime && (time - prevCheckTime < data.interval)) { return }\r\n      this.prevCheckTime = time\r\n\r\n      orderChanged = false\r\n      this.hoverElsIntersections.sort(sorter)\r\n      if (orderChanged) {\r\n        for (let i = 0; i < this.hoverElsIntersections.length; i++) {\r\n          this.hoverEls[i] = this.hoverElsIntersections[i].object.el\r\n        }\r\n        this.hover()\r\n      }\r\n    }\r\n  })(),\r\n  onGrabStartButton: function (evt) {\r\n    let carried = this.state.get(this.GRAB_EVENT)\r\n    this.dispatchMouseEventAll('mousedown', this.el)\r\n    this.gehClicking = new Set(this.hoverEls)\r\n    if (!carried) {\r\n      carried = this.findTarget(this.GRAB_EVENT, {\r\n        hand: this.el,\r\n        buttonEvent: evt\r\n      })\r\n      if (carried) {\r\n        this.state.set(this.GRAB_EVENT, carried)\r\n        this._unHover(carried)\r\n      }\r\n    }\r\n  },\r\n  onGrabEndButton: function (evt) {\r\n    const clickables = this.hoverEls.filter(h => this.gehClicking.has(h))\r\n    const grabbed = this.state.get(this.GRAB_EVENT)\r\n    const endEvt = {hand: this.el, buttonEvent: evt}\r\n    this.dispatchMouseEventAll('mouseup', this.el)\r\n    for (let i = 0; i < clickables.length; i++) {\r\n      this.dispatchMouseEvent(clickables[i], 'click', this.el)\r\n    }\r\n    this.gehClicking.clear()\r\n    // check if grabbed entity accepts ungrab event\r\n    if (grabbed && !this.emitCancelable(grabbed, this.UNGRAB_EVENT, endEvt)) {\r\n      /* push to top of stack so a drop followed by re-grab gets the same\r\n         target */\r\n      this.promoteHoveredEl(this.state.get(this.GRAB_EVENT))\r\n      this.state.delete(this.GRAB_EVENT)\r\n      this.hover()\r\n    }\r\n  },\r\n  onStretchStartButton: function (evt) {\r\n    let stretched = this.state.get(this.STRETCH_EVENT)\r\n    if (!stretched) {\r\n      stretched = this.findTarget(this.STRETCH_EVENT, {\r\n        hand: this.el,\r\n        buttonEvent: evt\r\n      })\r\n      if (stretched) {\r\n        this.state.set(this.STRETCH_EVENT, stretched)\r\n        this._unHover(stretched)\r\n      }\r\n    }\r\n  },\r\n  onStretchEndButton: function (evt) {\r\n    const stretched = this.state.get(this.STRETCH_EVENT)\r\n    const endEvt = {hand: this.el, buttonEvent: evt}\r\n    // check if end event accepted\r\n    if (stretched &&\r\n        !this.emitCancelable(stretched, this.UNSTRETCH_EVENT, endEvt)) {\r\n      this.promoteHoveredEl(stretched)\r\n      this.state.delete(this.STRETCH_EVENT)\r\n      this.hover()\r\n    }\r\n  },\r\n  onDragDropStartButton: function (evt) {\r\n    let dragged = this.state.get(this.DRAG_EVENT)\r\n    this.dragging = true\r\n    if (this.hoverEls.length) {\r\n      this.gehDragged = new Set(this.hoverEls)\r\n      this.dispatchMouseEventAll('dragstart', this.el)\r\n    }\r\n    if (!dragged) {\r\n      /* prefer carried so that a drag started after a grab will work\r\n       with carried element rather than a currently intersected drop target.\r\n       fall back to queue in case a drag is initiated independent\r\n       of a grab */\r\n      if (this.state.get(this.GRAB_EVENT) &&\r\n          !this.emitCancelable(this.state.get(this.GRAB_EVENT), this.DRAG_EVENT,\r\n              {hand: this.el, buttonEvent: evt})) {\r\n        dragged = this.state.get(this.GRAB_EVENT)\r\n      } else {\r\n        dragged = this.findTarget(this.DRAG_EVENT, {\r\n          hand: this.el,\r\n          buttonEvent: evt\r\n        })\r\n      }\r\n      if (dragged) {\r\n        this.state.set(this.DRAG_EVENT, dragged)\r\n        this._unHover(dragged)\r\n      }\r\n    }\r\n  },\r\n  onDragDropEndButton: function (evt) {\r\n    const carried = this.state.get(this.DRAG_EVENT)\r\n    this.dragging = false // keep _unHover() from activating another droptarget\r\n    this.gehDragged.forEach(carried => {\r\n      this.dispatchMouseEvent(carried, 'dragend', this.el)\r\n      // fire event both ways for all intersected targets\r\n      this.dispatchMouseEventAll('drop', carried, true, true)\r\n      this.dispatchMouseEventAll('dragleave', carried, true, true)\r\n    })\r\n    this.gehDragged.clear()\r\n    if (carried) {\r\n      const ddEvt = {\r\n        hand: this.el,\r\n        dropped: carried,\r\n        on: null,\r\n        buttonEvent: evt\r\n      }\r\n      const endEvt = {hand: this.el, buttonEvent: evt}\r\n      const dropTarget = this.findTarget(this.DRAGDROP_EVENT, ddEvt, true)\r\n      if (dropTarget) {\r\n        ddEvt.on = dropTarget\r\n        this.emitCancelable(carried, this.DRAGDROP_EVENT, ddEvt)\r\n        this._unHover(dropTarget)\r\n      }\r\n      // check if end event accepted\r\n      if (!this.emitCancelable(carried, this.UNDRAG_EVENT, endEvt)) {\r\n        this.promoteHoveredEl(carried)\r\n        this.state.delete(this.DRAG_EVENT)\r\n        this.hover()\r\n      }\r\n    }\r\n  },\r\n  processHitEl: function (hitEl, intersection) {\r\n    const dist = intersection && intersection.distance\r\n    const sects = this.hoverElsIntersections\r\n    const hoverEls = this.hoverEls\r\n    const hitElIndex = this.hoverEls.indexOf(hitEl)\r\n    let hoverNeedsUpdate = false\r\n    if (hitElIndex === -1) {\r\n      hoverNeedsUpdate = true\r\n      // insert in order of distance when available\r\n      if (dist != null) {\r\n        let i = 0\r\n        while (i < sects.length && dist < sects[i].distance) { i++ }\r\n        hoverEls.splice(i, 0, hitEl)\r\n        sects.splice(i, 0, intersection)\r\n      } else {\r\n        hoverEls.push(hitEl)\r\n        sects.push({ object: { el: hitEl } })\r\n      }\r\n      this.dispatchMouseEvent(hitEl, 'mouseover', this.el)\r\n      if (this.dragging && this.gehDragged.size) {\r\n        // events on targets and on dragged\r\n        this.gehDragged.forEach(dragged => {\r\n          this.dispatchMouseEventAll('dragenter', dragged, true, true)\r\n        })\r\n      }\r\n    }\r\n    return hoverNeedsUpdate\r\n  },\r\n  onHit: function (evt) {\r\n    const hitEl = evt.detail[this.data.colliderEventProperty]\r\n    let hoverNeedsUpdate = 0\r\n    if (!hitEl) { return }\r\n    if (Array.isArray(hitEl)) {\r\n      for (let i = 0, sect; i < hitEl.length; i++) {\r\n        sect = evt.detail.intersections && evt.detail.intersections[i]\r\n        hoverNeedsUpdate += this.processHitEl(hitEl[i], sect)\r\n      }\r\n    } else {\r\n      hoverNeedsUpdate += this.processHitEl(hitEl, null)\r\n    }\r\n    if (hoverNeedsUpdate) { this.hover() }\r\n  },\r\n  /* search collided entities for target to hover/dragover */\r\n  hover: function () {\r\n    var hvrevt, hoverEl\r\n    // end previous hover\r\n    if (this.state.has(this.HOVER_EVENT)) {\r\n      this._unHover(this.state.get(this.HOVER_EVENT), true)\r\n    }\r\n    if (this.state.has(this.DRAGOVER_EVENT)) {\r\n      this._unHover(this.state.get(this.DRAGOVER_EVENT), true)\r\n    }\r\n    if (this.dragging && this.state.get(this.DRAG_EVENT)) {\r\n      hvrevt = {\r\n        hand: this.el,\r\n        hovered: hoverEl,\r\n        carried: this.state.get(this.DRAG_EVENT)\r\n      }\r\n      hoverEl = this.findTarget(this.DRAGOVER_EVENT, hvrevt, true)\r\n      if (hoverEl) {\r\n        this.emitCancelable(this.state.get(this.DRAG_EVENT), this.DRAGOVER_EVENT, hvrevt)\r\n        this.state.set(this.DRAGOVER_EVENT, hoverEl)\r\n      }\r\n    }\r\n    // fallback to hover if not dragging or dragover wasn't successful\r\n    if (!this.state.has(this.DRAGOVER_EVENT)) {\r\n      hoverEl = this.findTarget(this.HOVER_EVENT, { hand: this.el }, true)\r\n      if (hoverEl) {\r\n        this.state.set(this.HOVER_EVENT, hoverEl)\r\n      }\r\n    }\r\n  },\r\n  /* called when controller moves out of collision range of entity */\r\n  unHover: function (evt) {\r\n    const clearedEls = evt.detail[this.data.colliderEndEventProperty]\r\n    if (clearedEls) {\r\n      if (Array.isArray(clearedEls)) {\r\n        clearedEls.forEach(el => this._unHover(el))\r\n      } else {\r\n        this._unHover(clearedEls)\r\n      }\r\n    }\r\n  },\r\n  /* inner unHover steps needed regardless of cause of unHover */\r\n  _unHover: function (el, skipNextHover) {\r\n    let unHovered = false\r\n    let evt\r\n    if (el === this.state.get(this.DRAGOVER_EVENT)) {\r\n      this.state.delete(this.DRAGOVER_EVENT)\r\n      unHovered = true\r\n      evt = {\r\n        hand: this.el,\r\n        hovered: el,\r\n        carried: this.state.get(this.DRAG_EVENT)\r\n      }\r\n      this.emitCancelable(el, this.UNDRAGOVER_EVENT, evt)\r\n      if (this.state.has(this.DRAG_EVENT)) {\r\n        this.emitCancelable(\r\n          this.state.get(this.DRAG_EVENT),\r\n          this.UNDRAGOVER_EVENT,\r\n          evt\r\n        )\r\n      }\r\n    }\r\n    if (el === this.state.get(this.HOVER_EVENT)) {\r\n      this.state.delete(this.HOVER_EVENT)\r\n      unHovered = true\r\n      this.emitCancelable(el, this.UNHOVER_EVENT, { hand: this.el })\r\n    }\r\n    // activate next target, if present\r\n    if (unHovered && !skipNextHover) {\r\n      this.hover()\r\n    }\r\n  },\r\n  unWatch: function (evt) {\r\n    const clearedEls = evt.detail[this.data.colliderEndEventProperty]\r\n    if (clearedEls) {\r\n      if (Array.isArray(clearedEls)) {\r\n        clearedEls.forEach(el => this._unWatch(el))\r\n      } else {\r\n        // deprecation path: sphere-collider\r\n        this._unWatch(clearedEls)\r\n      }\r\n    }\r\n  },\r\n  _unWatch: function (target) {\r\n    var hoverIndex = this.hoverEls.indexOf(target)\r\n    if (hoverIndex !== -1) {\r\n      this.hoverEls.splice(hoverIndex, 1)\r\n      this.hoverElsIntersections.splice(hoverIndex, 1)\r\n    }\r\n    this.gehDragged.forEach(dragged => {\r\n      this.dispatchMouseEvent(target, 'dragleave', dragged)\r\n      this.dispatchMouseEvent(dragged, 'dragleave', target)\r\n    })\r\n    this.dispatchMouseEvent(target, 'mouseout', this.el)\r\n  },\r\n  registerListeners: function () {\r\n    this.el.addEventListener(this.data.colliderEvent, this.onHit)\r\n    this.el.addEventListener(this.data.colliderEndEvent, this.unWatch)\r\n    this.el.addEventListener(this.data.colliderEndEvent, this.unHover)\r\n\r\n    // binding order to keep grabEnd from triggering dragover\r\n    // again before dragDropEnd can delete its carried state\r\n    this.data.grabStartButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onGrabStartButton)\r\n    })\r\n    this.data.stretchStartButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onStretchStartButton)\r\n    })\r\n    this.data.dragDropStartButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onDragDropStartButton)\r\n    })\r\n    this.data.dragDropEndButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onDragDropEndButton)\r\n    })\r\n    this.data.stretchEndButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onStretchEndButton)\r\n    })\r\n    this.data.grabEndButtons.forEach(b => {\r\n      this.el.addEventListener(b, this.onGrabEndButton)\r\n    })\r\n  },\r\n  unRegisterListeners: function (data) {\r\n    data = data || this.data\r\n    if (Object.keys(data).length === 0) {\r\n      // Empty object passed on initalization\r\n      return\r\n    }\r\n    this.el.removeEventListener(data.colliderEvent, this.onHit)\r\n    this.el.removeEventListener(data.colliderEndEvent, this.unHover)\r\n    this.el.removeEventListener(data.colliderEndEvent, this.unWatch)\r\n\r\n    data.grabStartButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onGrabStartButton)\r\n    })\r\n    data.grabEndButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onGrabEndButton)\r\n    })\r\n    data.stretchStartButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onStretchStartButton)\r\n    })\r\n    data.stretchEndButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onStretchEndButton)\r\n    })\r\n    data.dragDropStartButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onDragDropStartButton)\r\n    })\r\n    data.dragDropEndButtons.forEach(b => {\r\n      this.el.removeEventListener(b, this.onDragDropEndButton)\r\n    })\r\n  },\r\n  emitCancelable: function (target, name, detail) {\r\n    var data, evt\r\n    detail = detail || {}\r\n    data = { bubbles: true, cancelable: true, detail: detail }\r\n    data.detail.target = data.detail.target || target\r\n    evt = new window.CustomEvent(name, data)\r\n    return target.dispatchEvent(evt)\r\n  },\r\n  dispatchMouseEvent: function (target, name, relatedTarget) {\r\n    var mEvt = new window.MouseEvent(name, { relatedTarget: relatedTarget })\r\n    target.dispatchEvent(mEvt)\r\n  },\r\n  dispatchMouseEventAll: function (name, relatedTarget, filterUsed, alsoReverse) {\r\n    let els = this.hoverEls\r\n    if (filterUsed) {\r\n      els = els\r\n        .filter(el => el !== this.state.get(this.GRAB_EVENT) &&\r\n                el !== this.state.get(this.DRAG_EVENT) &&\r\n                el !== this.state.get(this.STRETCH_EVENT) &&\r\n                !this.gehDragged.has(el))\r\n    }\r\n    if (alsoReverse) {\r\n      for (let i = 0; i < els.length; i++) {\r\n        this.dispatchMouseEvent(els[i], name, relatedTarget)\r\n        this.dispatchMouseEvent(relatedTarget, name, els[i])\r\n      }\r\n    } else {\r\n      for (let i = 0; i < els.length; i++) {\r\n        this.dispatchMouseEvent(els[i], name, relatedTarget)\r\n      }\r\n    }\r\n  },\r\n  findTarget: function (evType, detail, filterUsed) {\r\n    var elIndex\r\n    var eligibleEls = this.hoverEls\r\n    if (filterUsed) {\r\n      eligibleEls = eligibleEls\r\n        .filter(el => el !== this.state.get(this.GRAB_EVENT) &&\r\n                el !== this.state.get(this.DRAG_EVENT) &&\r\n                el !== this.state.get(this.STRETCH_EVENT))\r\n    }\r\n    for (elIndex = eligibleEls.length - 1; elIndex >= 0; elIndex--) {\r\n      if (!this.emitCancelable(eligibleEls[elIndex], evType, detail)) {\r\n        return eligibleEls[elIndex]\r\n      }\r\n    }\r\n    return null\r\n  },\r\n  // Helper to ensure dropping and regrabbing finds the same target for\r\n  // for order-sorted hoverEls (grabbing; no-op for distance-sorted (pointing)\r\n  promoteHoveredEl: function (el) {\r\n    var hoverIndex = this.hoverEls.indexOf(el)\r\n    if (hoverIndex !== -1 &&\r\n        this.hoverElsIntersections[hoverIndex].distance == null) {\r\n      this.hoverEls.splice(hoverIndex, 1)\r\n      const sect = this.hoverElsIntersections.splice(hoverIndex, 1)\r\n      this.hoverEls.push(el)\r\n      this.hoverElsIntersections.push(sect)\r\n    }\r\n  }\r\n})\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/index.js\n// module id = 6\n// module chunks = 0","/* global AFRAME */\r\nAFRAME.registerSystem('super-hands', {\r\n  init: function () {\r\n    this.superHands = []\r\n  },\r\n  registerMe: function (comp) {\r\n    // when second hand registers, store links\r\n    if (this.superHands.length === 1) {\r\n      this.superHands[0].otherSuperHand = comp\r\n      comp.otherSuperHand = this.superHands[0]\r\n    }\r\n    this.superHands.push(comp)\r\n  },\r\n  unregisterMe: function (comp) {\r\n    var index = this.superHands.indexOf(comp)\r\n    if (index !== -1) {\r\n      this.superHands.splice(index, 1)\r\n    }\r\n    this.superHands.forEach(x => {\r\n      if (x.otherSuperHand === comp) { x.otherSuperHand = null }\r\n    })\r\n  }\r\n})\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/systems/super-hands-system.js\n// module id = 7\n// module chunks = 0","/* global AFRAME */\r\nAFRAME.registerComponent('hoverable', {\r\n  init: function () {\r\n    this.HOVERED_STATE = 'hovered'\r\n    this.HOVER_EVENT = 'hover-start'\r\n    this.UNHOVER_EVENT = 'hover-end'\r\n\r\n    this.hoverers = []\r\n\r\n    this.start = this.start.bind(this)\r\n    this.end = this.end.bind(this)\r\n\r\n    this.el.addEventListener(this.HOVER_EVENT, this.start)\r\n    this.el.addEventListener(this.UNHOVER_EVENT, this.end)\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.HOVER_EVENT, this.start)\r\n    this.el.removeEventListener(this.UNHOVER_EVENT, this.end)\r\n  },\r\n  start: function (evt) {\r\n    if (evt.defaultPrevented) { return }\r\n    this.el.addState(this.HOVERED_STATE)\r\n    if (this.hoverers.indexOf(evt.detail.hand) === -1) {\r\n      this.hoverers.push(evt.detail.hand)\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  end: function (evt) {\r\n    if (evt.defaultPrevented) { return }\r\n    var handIndex = this.hoverers.indexOf(evt.detail.hand)\r\n    if (handIndex !== -1) {\r\n      this.hoverers.splice(handIndex, 1)\r\n    }\r\n    if (this.hoverers.length < 1) {\r\n      this.el.removeState(this.HOVERED_STATE)\r\n    }\r\n  }\r\n})\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/hoverable.js\n// module id = 8\n// module chunks = 0","/* global AFRAME, THREE */\r\nconst inherit = AFRAME.utils.extendDeep\r\nconst physicsCore = require('./prototypes/physics-grab-proto.js')\r\nconst buttonsCore = require('./prototypes/buttons-proto.js')\r\n// new object with all core modules\r\nconst base = inherit({}, physicsCore, buttonsCore)\r\nAFRAME.registerComponent('grabbable', inherit(base, {\r\n  schema: {\r\n    maxGrabbers: {type: 'int', default: NaN},\r\n    invert: {default: false},\r\n    suppressY: {default: false}\r\n  },\r\n  init: function () {\r\n    this.GRABBED_STATE = 'grabbed'\r\n    this.GRAB_EVENT = 'grab-start'\r\n    this.UNGRAB_EVENT = 'grab-end'\r\n    this.grabbed = false\r\n    this.grabbers = []\r\n    this.constraints = new Map()\r\n    this.deltaPositionIsValid = false\r\n    this.grabDistance = undefined\r\n    this.grabDirection = {x: 0, y: 0, z: -1}\r\n    this.grabOffset = {x: 0, y: 0, z: 0}\r\n    // persistent object speeds up repeat setAttribute calls\r\n    this.destPosition = {x: 0, y: 0, z: 0}\r\n    this.deltaPosition = new THREE.Vector3()\r\n    this.targetPosition = new THREE.Vector3()\r\n    this.physicsInit()\r\n\r\n    this.el.addEventListener(this.GRAB_EVENT, e => this.start(e))\r\n    this.el.addEventListener(this.UNGRAB_EVENT, e => this.end(e))\r\n    this.el.addEventListener('mouseout', e => this.lostGrabber(e))\r\n  },\r\n  update: function () {\r\n    this.physicsUpdate()\r\n    this.xFactor = (this.data.invert) ? -1 : 1\r\n    this.zFactor = (this.data.invert) ? -1 : 1\r\n    this.yFactor = ((this.data.invert) ? -1 : 1) * !this.data.suppressY\r\n  },\r\n  tick: function () {\r\n    var entityPosition\r\n    if (this.grabber) {\r\n      // reflect on z-axis to point in same direction as the laser\r\n      this.targetPosition.copy(this.grabDirection)\r\n      this.targetPosition\r\n          .applyQuaternion(this.grabber.object3D.getWorldQuaternion())\r\n          .setLength(this.grabDistance)\r\n          .add(this.grabber.object3D.getWorldPosition())\r\n          .add(this.grabOffset)\r\n      if (this.deltaPositionIsValid) {\r\n        // relative position changes work better with nested entities\r\n        this.deltaPosition.sub(this.targetPosition)\r\n        entityPosition = this.el.getAttribute('position')\r\n        this.destPosition.x =\r\n            entityPosition.x - this.deltaPosition.x * this.xFactor\r\n        this.destPosition.y =\r\n            entityPosition.y - this.deltaPosition.y * this.yFactor\r\n        this.destPosition.z =\r\n            entityPosition.z - this.deltaPosition.z * this.zFactor\r\n        this.el.setAttribute('position', this.destPosition)\r\n      } else {\r\n        this.deltaPositionIsValid = true\r\n      }\r\n      this.deltaPosition.copy(this.targetPosition)\r\n    }\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.GRAB_EVENT, this.start)\r\n    this.el.removeEventListener(this.UNGRAB_EVENT, this.end)\r\n    this.physicsRemove()\r\n  },\r\n  start: function (evt) {\r\n    if (evt.defaultPrevented || !this.startButtonOk(evt)) {\r\n      return\r\n    }\r\n    // room for more grabbers?\r\n    const grabAvailable = !Number.isFinite(this.data.maxGrabbers) ||\r\n        this.grabbers.length < this.data.maxGrabbers\r\n\r\n    if (this.grabbers.indexOf(evt.detail.hand) === -1 && grabAvailable) {\r\n      if (!evt.detail.hand.object3D) {\r\n        console.warn('grabbable entities must have an object3D')\r\n        return\r\n      }\r\n      this.grabbers.push(evt.detail.hand)\r\n      // initiate physics if available, otherwise manual\r\n      if (!this.physicsStart(evt) && !this.grabber) {\r\n        this.grabber = evt.detail.hand\r\n        this.resetGrabber()\r\n      }\r\n      // notify super-hands that the gesture was accepted\r\n      if (evt.preventDefault) { evt.preventDefault() }\r\n      this.grabbed = true\r\n      this.el.addState(this.GRABBED_STATE)\r\n    }\r\n  },\r\n  end: function (evt) {\r\n    const handIndex = this.grabbers.indexOf(evt.detail.hand)\r\n    if (evt.defaultPrevented || !this.endButtonOk(evt)) { return }\r\n    if (handIndex !== -1) {\r\n      this.grabbers.splice(handIndex, 1)\r\n      this.grabber = this.grabbers[0]\r\n    }\r\n    this.physicsEnd(evt)\r\n    if (!this.resetGrabber()) {\r\n      this.grabbed = false\r\n      this.el.removeState(this.GRABBED_STATE)\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  resetGrabber: function () {\r\n    let raycaster\r\n    if (!this.grabber) {\r\n      return false\r\n    }\r\n    raycaster = this.grabber.getAttribute('raycaster')\r\n    this.deltaPositionIsValid = false\r\n    this.grabDistance = this.el.object3D.getWorldPosition()\r\n        .distanceTo(this.grabber.object3D.getWorldPosition())\r\n    if (raycaster) {\r\n      this.grabDirection = raycaster.direction\r\n      this.grabOffset = raycaster.origin\r\n    }\r\n    return true\r\n  },\r\n  lostGrabber: function (evt) {\r\n    let i = this.grabbers.indexOf(evt.relatedTarget)\r\n    // if a queued, non-physics grabber leaves the collision zone, forget it\r\n    if (i !== -1 && evt.relatedTarget !== this.grabber &&\r\n        !this.physicsIsConstrained(evt.relatedTarget)) {\r\n      this.grabbers.splice(i, 1)\r\n    }\r\n  }\r\n}))\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/grabbable.js\n// module id = 9\n// module chunks = 0","// base code used by grabbable for physics interactions\r\nmodule.exports = {\r\n  schema: {\r\n    usePhysics: {default: 'ifavailable'}\r\n  },\r\n  physicsInit: function () {\r\n    this.constraints = new Map()\r\n  },\r\n  physicsUpdate: function () {\r\n    if (this.data.usePhysics === 'never' && this.constraints.size) {\r\n      this.physicsClear()\r\n    }\r\n  },\r\n  physicsRemove: function () {\r\n    this.physicsClear()\r\n  },\r\n  physicsStart: function (evt) {\r\n    // initiate physics constraint if available and not already existing\r\n    if (this.data.usePhysics !== 'never' && this.el.body &&\r\n        evt.detail.hand.body && !this.constraints.has(evt.detail.hand)) {\r\n      const newConId = Math.random().toString(36).substr(2, 9)\r\n      this.el.setAttribute('constraint__' + newConId, {\r\n        target: evt.detail.hand\r\n      })\r\n      this.constraints.set(evt.detail.hand, newConId)\r\n      return true\r\n    }\r\n    // Prevent manual grab by returning true\r\n    if (this.data.usePhysics === 'only') { return true }\r\n    return false\r\n  },\r\n  physicsEnd: function (evt) {\r\n    let constraintId = this.constraints.get(evt.detail.hand)\r\n    if (constraintId) {\r\n      this.el.removeAttribute('constraint__' + constraintId)\r\n      this.constraints.delete(evt.detail.hand)\r\n    }\r\n  },\r\n  physicsClear: function () {\r\n    if (this.el.body) {\r\n      for (let c of this.constraints.values()) {\r\n        this.el.body.world.removeConstraint(c)\r\n      }\r\n    }\r\n    this.constraints.clear()\r\n  },\r\n  physicsIsConstrained: function (el) {\r\n    return this.constraints.has(el)\r\n  },\r\n  physicsIsGrabbing () {\r\n    return this.constraints.size > 0\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/prototypes/physics-grab-proto.js\n// module id = 10\n// module chunks = 0","/* global AFRAME, THREE */\r\nconst inherit = AFRAME.utils.extendDeep\r\nconst buttonsCore = require('./prototypes/buttons-proto.js')\r\n// new object with all core modules\r\nconst base = inherit({}, buttonsCore)\r\nAFRAME.registerComponent('stretchable', inherit(base, {\r\n  schema: {\r\n    usePhysics: {default: 'ifavailable'},\r\n    invert: {default: false},\r\n    physicsUpdateRate: {default: 100}\r\n  },\r\n  init: function () {\r\n    this.STRETCHED_STATE = 'stretched'\r\n    this.STRETCH_EVENT = 'stretch-start'\r\n    this.UNSTRETCH_EVENT = 'stretch-end'\r\n    this.stretched = false\r\n    this.stretchers = []\r\n\r\n    this.scale = new THREE.Vector3()\r\n    this.handPos = new THREE.Vector3()\r\n    this.otherHandPos = new THREE.Vector3()\r\n\r\n    this.start = this.start.bind(this)\r\n    this.end = this.end.bind(this)\r\n\r\n    this.el.addEventListener(this.STRETCH_EVENT, this.start)\r\n    this.el.addEventListener(this.UNSTRETCH_EVENT, this.end)\r\n  },\r\n  update: function (oldDat) {\r\n    this.updateBodies = AFRAME.utils.throttleTick(\r\n      this._updateBodies,\r\n      this.data.physicsUpdateRate,\r\n      this\r\n    )\r\n  },\r\n  tick: function (time, timeDelta) {\r\n    if (!this.stretched) { return }\r\n    this.scale.copy(this.el.getAttribute('scale'))\r\n    this.handPos.copy(this.stretchers[0].getAttribute('position'))\r\n    this.otherHandPos.copy(this.stretchers[1].getAttribute('position'))\r\n    const currentStretch = this.handPos.distanceTo(this.otherHandPos)\r\n    let deltaStretch = 1\r\n    if (this.previousStretch !== null && currentStretch !== 0) {\r\n      deltaStretch = Math.pow(\r\n          currentStretch / this.previousStretch,\r\n          (this.data.invert)\r\n            ? -1\r\n            : 1\r\n      )\r\n    }\r\n    this.previousStretch = currentStretch\r\n    if (this.previousPhysicsStretch == null) {\r\n      // establish correct baseline even if throttled function isn't called\r\n      this.previousPhysicsStretch = currentStretch\r\n    }\r\n    this.scale.multiplyScalar(deltaStretch)\r\n    this.el.setAttribute('scale', this.scale)\r\n    // scale update for all nested physics bodies (throttled)\r\n    this.updateBodies(time, timeDelta)\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.STRETCH_EVENT, this.start)\r\n    this.el.removeEventListener(this.UNSTRETCH_EVENT, this.end)\r\n  },\r\n  start: function (evt) {\r\n    if (this.stretched || this.stretchers.includes(evt.detail.hand) ||\r\n        !this.startButtonOk(evt) || evt.defaultPrevented) {\r\n      return\r\n    } // already stretched or already captured this hand or wrong button\r\n    this.stretchers.push(evt.detail.hand)\r\n    if (this.stretchers.length === 2) {\r\n      this.stretched = true\r\n      this.previousStretch = null\r\n      this.previousPhysicsStretch = null\r\n      this.el.addState(this.STRETCHED_STATE)\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() } // gesture accepted\r\n  },\r\n  end: function (evt) {\r\n    var stretcherIndex = this.stretchers.indexOf(evt.detail.hand)\r\n    if (evt.defaultPrevented || !this.endButtonOk(evt)) { return }\r\n    if (stretcherIndex !== -1) {\r\n      this.stretchers.splice(stretcherIndex, 1)\r\n      this.stretched = false\r\n      this.el.removeState(this.STRETCHED_STATE)\r\n      // override throttle to push last stretch to physics bodies\r\n      this._updateBodies()\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  _updateBodies: function () {\r\n    if (!this.el.body || this.data.usePhysics === 'never') { return }\r\n    const currentStretch = this.previousStretch // last visible geometry stretch\r\n    let deltaStretch = 1\r\n    if (this.previousPhysicsStretch !== null && currentStretch > 0) {\r\n      deltaStretch = Math.pow(\r\n          currentStretch / this.previousPhysicsStretch,\r\n          (this.data.invert)\r\n            ? -1\r\n            : 1\r\n      )\r\n    }\r\n    this.previousPhysicsStretch = currentStretch\r\n    if (deltaStretch === 1) { return }\r\n    for (let c of this.el.childNodes) { this.stretchBody(c, deltaStretch) }\r\n    this.stretchBody(this.el, deltaStretch)\r\n  },\r\n  stretchBody: function (el, deltaStretch) {\r\n    if (!el.body) { return }\r\n    let physicsShape\r\n    let offset\r\n    for (let i = 0; i < el.body.shapes.length; i++) {\r\n      physicsShape = el.body.shapes[i]\r\n      if (physicsShape.halfExtents) {\r\n        physicsShape.halfExtents\r\n            .scale(deltaStretch, physicsShape.halfExtents)\r\n        physicsShape.updateConvexPolyhedronRepresentation()\r\n      } else if (physicsShape.radius) {\r\n        physicsShape.radius *= deltaStretch\r\n        physicsShape.updateBoundingSphereRadius()\r\n      } else if (!this.shapeWarned) {\r\n        console.warn('Unable to stretch physics body: unsupported shape')\r\n        this.shapeWarned = true\r\n      }\r\n      // also move offset to match scale change\r\n      offset = el.body.shapeOffsets[i]\r\n      offset.scale(deltaStretch, offset)\r\n    }\r\n    el.body.updateBoundingRadius()\r\n  }\r\n}))\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/stretchable.js\n// module id = 11\n// module chunks = 0","/* global AFRAME */\r\nconst inherit = AFRAME.utils.extendDeep\r\nconst buttonCore = require('./prototypes/buttons-proto.js')\r\n\r\nAFRAME.registerComponent('drag-droppable', inherit({}, buttonCore, {\r\n  init: function () {\r\n    console.warn('Warning: drag-droppable is deprecated. Use draggable and droppable components instead')\r\n    this.HOVERED_STATE = 'dragover'\r\n    this.DRAGGED_STATE = 'dragged'\r\n    this.HOVER_EVENT = 'dragover-start'\r\n    this.UNHOVER_EVENT = 'dragover-end'\r\n    this.DRAG_EVENT = 'drag-start'\r\n    this.UNDRAG_EVENT = 'drag-end'\r\n    this.DRAGDROP_EVENT = 'drag-drop'\r\n\r\n    this.hoverStart = this.hoverStart.bind(this)\r\n    this.dragStart = this.dragStart.bind(this)\r\n    this.hoverEnd = this.hoverEnd.bind(this)\r\n    this.dragEnd = this.dragEnd.bind(this)\r\n    this.dragDrop = this.dragDrop.bind(this)\r\n\r\n    this.el.addEventListener(this.HOVER_EVENT, this.hoverStart)\r\n    this.el.addEventListener(this.DRAG_EVENT, this.dragStart)\r\n    this.el.addEventListener(this.UNHOVER_EVENT, this.hoverEnd)\r\n    this.el.addEventListener(this.UNDRAG_EVENT, this.dragEnd)\r\n    this.el.addEventListener(this.DRAGDROP_EVENT, this.dragDrop)\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.HOVER_EVENT, this.hoverStart)\r\n    this.el.removeEventListener(this.DRAG_EVENT, this.dragStart)\r\n    this.el.removeEventListener(this.UNHOVER_EVENT, this.hoverEnd)\r\n    this.el.removeEventListener(this.UNDRAG_EVENT, this.dragEnd)\r\n    this.el.removeEventListener(this.DRAGDROP_EVENT, this.dragDrop)\r\n  },\r\n  hoverStart: function (evt) {\r\n    this.el.addState(this.HOVERED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  dragStart: function (evt) {\r\n    if (!this.startButtonOk(evt)) { return }\r\n    this.el.addState(this.DRAGGED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  hoverEnd: function (evt) {\r\n    this.el.removeState(this.HOVERED_STATE)\r\n  },\r\n  dragEnd: function (evt) {\r\n    if (!this.endButtonOk(evt)) { return }\r\n    this.el.removeState(this.DRAGGED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  dragDrop: function (evt) {\r\n    if (!this.endButtonOk(evt)) { return }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  }\r\n}))\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/drag-droppable.js\n// module id = 12\n// module chunks = 0","/* global AFRAME */\r\nconst inherit = AFRAME.utils.extendDeep\r\nconst buttonCore = require('./prototypes/buttons-proto.js')\r\n\r\nAFRAME.registerComponent('draggable', inherit({}, buttonCore, {\r\n  init: function () {\r\n    this.DRAGGED_STATE = 'dragged'\r\n    this.DRAG_EVENT = 'drag-start'\r\n    this.UNDRAG_EVENT = 'drag-end'\r\n\r\n    this.dragStartBound = this.dragStart.bind(this)\r\n    this.dragEndBound = this.dragEnd.bind(this)\r\n\r\n    this.el.addEventListener(this.DRAG_EVENT, this.dragStartBound)\r\n    this.el.addEventListener(this.UNDRAG_EVENT, this.dragEndBound)\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.DRAG_EVENT, this.dragStart)\r\n    this.el.removeEventListener(this.UNDRAG_EVENT, this.dragEnd)\r\n  },\r\n  dragStart: function (evt) {\r\n    if (evt.defaultPrevented || !this.startButtonOk(evt)) { return }\r\n    this.el.addState(this.DRAGGED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  dragEnd: function (evt) {\r\n    if (evt.defaultPrevented || !this.endButtonOk(evt)) { return }\r\n    this.el.removeState(this.DRAGGED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  }\r\n}))\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/draggable.js\n// module id = 13\n// module chunks = 0","/* global AFRAME */\r\nfunction elementMatches (el, selector) {\r\n  if (el.matches) { return el.matches(selector) }\r\n  if (el.msMatchesSelector) { return el.msMatchesSelector(selector) }\r\n  if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector) }\r\n}\r\nAFRAME.registerComponent('droppable', {\r\n  schema: {\r\n    accepts: {default: ''},\r\n    autoUpdate: {default: true},\r\n    acceptEvent: {default: ''},\r\n    rejectEvent: {default: ''}\r\n  },\r\n  multiple: true,\r\n  init: function () {\r\n    this.HOVERED_STATE = 'dragover'\r\n    this.HOVER_EVENT = 'dragover-start'\r\n    this.UNHOVER_EVENT = 'dragover-end'\r\n    this.DRAGDROP_EVENT = 'drag-drop'\r\n\r\n    // better for Sinon spying if original method not overwritten\r\n    this.hoverStartBound = this.hoverStart.bind(this)\r\n    this.hoverEndBound = this.hoverEnd.bind(this)\r\n    this.dragDropBound = this.dragDrop.bind(this)\r\n    this.mutateAcceptsBound = this.mutateAccepts.bind(this)\r\n\r\n    this.acceptableEntities = []\r\n    this.observer = new window.MutationObserver(this.mutateAcceptsBound)\r\n    this.observerOpts = {childList: true, subtree: true}\r\n\r\n    this.el.addEventListener(this.HOVER_EVENT, this.hoverStartBound)\r\n    this.el.addEventListener(this.UNHOVER_EVENT, this.hoverEndBound)\r\n    this.el.addEventListener(this.DRAGDROP_EVENT, this.dragDropBound)\r\n  },\r\n  update: function () {\r\n    if (this.data.accepts.length) {\r\n      this.acceptableEntities = Array.prototype.slice.call(\r\n        this.el.sceneEl.querySelectorAll(this.data.accepts)\r\n      )\r\n    } else {\r\n      this.acceptableEntities = null\r\n    }\r\n    if (this.data.autoUpdate && this.acceptableEntities != null) {\r\n      this.observer.observe(this.el.sceneEl, this.observerOpts)\r\n    } else {\r\n      this.observer.disconnect()\r\n    }\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.HOVER_EVENT, this.hoverStartBound)\r\n    this.el.removeEventListener(this.UNHOVER_EVENT, this.hoverEndBound)\r\n    this.el.removeEventListener(this.DRAGDROP_EVENT, this.dragDropBound)\r\n    this.observer.disconnect()\r\n  },\r\n  mutateAccepts: function (mutations) {\r\n    const query = this.data.accepts\r\n    mutations.forEach(mutation => {\r\n      mutation.addedNodes.forEach(added => {\r\n        if (elementMatches(added, query)) {\r\n          this.acceptableEntities.push(added)\r\n        }\r\n      })\r\n    })\r\n  },\r\n  entityAcceptable: function (entity) {\r\n    const acceptableEntities = this.acceptableEntities\r\n    if (acceptableEntities == null) { return true }\r\n    for (let item of acceptableEntities) {\r\n      if (item === entity) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  },\r\n  hoverStart: function (evt) {\r\n    if (evt.defaultPrevented || !this.entityAcceptable(evt.detail.carried)) {\r\n      return\r\n    }\r\n    this.el.addState(this.HOVERED_STATE)\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  },\r\n  hoverEnd: function (evt) {\r\n    if (evt.defaultPrevented) { return }\r\n    this.el.removeState(this.HOVERED_STATE)\r\n  },\r\n  dragDrop: function (evt) {\r\n    if (evt.defaultPrevented) { return }\r\n    const dropped = evt.detail.dropped\r\n    if (!this.entityAcceptable(dropped)) {\r\n      if (this.data.rejectEvent.length) {\r\n        this.el.emit(this.data.rejectEvent, {el: dropped})\r\n      }\r\n      return\r\n    }\r\n    if (this.data.acceptEvent.length) {\r\n      this.el.emit(this.data.acceptEvent, {el: dropped})\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  }\r\n})\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/droppable.js\n// module id = 14\n// module chunks = 0","/* global AFRAME */\r\nconst buttonCore = require('./prototypes/buttons-proto.js')\r\nAFRAME.registerComponent('clickable', AFRAME.utils.extendDeep({}, buttonCore, {\r\n  schema: {\r\n    onclick: { type: 'string' }\r\n  },\r\n  init: function () {\r\n    this.CLICKED_STATE = 'clicked'\r\n    this.CLICK_EVENT = 'grab-start'\r\n    this.UNCLICK_EVENT = 'grab-end'\r\n    this.clickers = []\r\n\r\n    this.start = this.start.bind(this)\r\n    this.end = this.end.bind(this)\r\n    this.el.addEventListener(this.CLICK_EVENT, this.start)\r\n    this.el.addEventListener(this.UNCLICK_EVENT, this.end)\r\n  },\r\n  remove: function () {\r\n    this.el.removeEventListener(this.CLICK_EVENT, this.start)\r\n    this.el.removeEventListener(this.UNCLICK_EVENT, this.end)\r\n  },\r\n  start: function (evt) {\r\n    if (evt.defaultPrevented || !this.startButtonOk(evt)) { return }\r\n    this.el.addState(this.CLICKED_STATE)\r\n    if (this.clickers.indexOf(evt.detail.hand) === -1) {\r\n      this.clickers.push(evt.detail.hand)\r\n      if (evt.preventDefault) { evt.preventDefault() }\r\n    }\r\n  },\r\n  end: function (evt) {\r\n    const handIndex = this.clickers.indexOf(evt.detail.hand)\r\n    if (evt.defaultPrevented || !this.endButtonOk(evt)) { return }\r\n    if (handIndex !== -1) {\r\n      this.clickers.splice(handIndex, 1)\r\n    }\r\n    if (this.clickers.length < 1) {\r\n      this.el.removeState(this.CLICKED_STATE)\r\n    }\r\n    if (evt.preventDefault) { evt.preventDefault() }\r\n  }\r\n}))\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/super-hands/reaction_components/clickable.js\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}